# 9월 13일

<br>

💻 **오늘 배운 것**

---

## line-height 속성

- 폰트사이즈가 변경되었을 때를 대비, 픽셀값으로 주지 않는 것을 권장
- **상속이 된다**
- `line-height` 1과 1em의 차이

  - 부모 요소에 폰트 사이즈와 그에 따른 `line-height`를 `em`값으로 주게 되면, **부모 요소의 폰트사이즈에 대한 em값이 자식에게 상속**됨
  - 부모 요소의 폰트 사이즈와 자식 요소의 폰트 사이즈가 다를 경우 문제가 발생할 수 있음..

  ```css
  .parent {
    font-size: 24px;
    line-height: 1em; // (24px)
  }

  .child {
    font-size: 30px; // 24px의 line-height가 그대로 상속되어 줄 사이가 겹치게 된다
    // 부모에게 line-height를 1로 줄 경우 자식의 폰트사이즈에 맞춰서 30px의 줄간격이 적용됨
  }
  ```

- `line-height`는 가능한 **단위 없이 작성하자**❗

<br>

- 내가 지정한 `font-size`보다 실제 높이가 더 큰 이유 → 폰트의 위 아래 공간에 리딩(leading)영역이라는 공간을 기본적으로 넣어둠(여러 줄일 때의 가독성을 위한 것)

  - **font-size** 속성의 값이 의미하는 것은 **리딩영역을 제외**한 공간! 실제 contents area를 의미한다
  - **line-height**는 **리딩영역을 포함**한 값이다

- `line-height`의 초기값은 **normal** 이며, 실제 계산되는 값은 **폰트 종류에 따라 다르다** → font-size에 같은 px값을 줘도 폰트 종류가 다르면 높이가 다르게 나오는 것
  - 따라서 normal상태로 두기보다는 고정값을 지정하는 편이 좋음
- `line-height: 1;`
  - 현재 지정된 **font-size와 일치(1배)**하게 됨(**리딩영역을 제외**한 공간)
  - 폰트 종류에 따라 폰트의 해당 사이즈가 `line-height: 1;` 의 공간보다 큰 경우도 있음(삐져나오게 됨.. 특히 영어)
  - `line-height: 1;` 을 했을 때 위아래에 남는 공간은 폰트 디자이너가 설정한 영역이므로 우리가 제어하기는 힘듦! line-height 자체를 줄이는 방식으로 조절

<br>

## 상대 길이 단위 em, rem

- `em`
  - 부모 요소의 `font-size`를 기준으로 설정
  - 요소의 폰트 크기에 상응하는 유동적인 레이아웃을 만들 수 있음
  - 상대적인 기준을 가지므로 코드가 복잡해질 경우 계산값을 예측하기 어려워짐
    ```html
    <html>
      16px
      <body>
        0.5em -> 8px
        <div>
          0.5em -> 4px
          <p>
            0.7em -> ?
            <a>
              0.3em -> ? // 픽셀값이 소수점으로 떨어지므로 브라우저에서
              정상적으로 지원되지 않을 수 있음</a
            >
          </p>
        </div>
      </body>
    </html>
    ```
- `rem`
  - html(root요소)의 `font-size`를 기준으로 설정
  - 부모요소의 영향을 받지 않으므로 실수할 가능성이 적어지고, 계산도 쉬우므로 직관적

💡 멘토님의 말씀

기본적으로 `rem`을 많이 쓰고 버튼(large, medium, small) 등에 텍스트의 비율에 따라 달라져야 할 경우 `em`을 쓴다!

<br>
<br>

## 마진 병합 현상(margin collapsing)

- **인접한 블록 레벨 요소**의 **상하단 마진이 병합**되는 현상
  - 한쪽 마진이 더 크면 큰 쪽의 크기로 맞춰진다
- CSS에서 **의도한 동작**임

<br>

💡 해결 방법 1

- 마진 병합 현상은 root 요소에서는 일어나지 않는다
- 부모 요소에게 `display: flow-root;` 값을 지정하면 부모 자식 간 마짐 병합 현상이 사라짐

🚫 `display: flow-root;` 는 IE를 지원하지 않음

<br>

💡 해결 방법 2

- 부모 요소에 `display: inline-block;` 값을 지정
- 부모 자식 간 블록-블록의 관계가 아니므로 마진 병합 현상이 사라짐

🚫 부모 요소의 형제 블록 요소와의 마진 병합도 사라져 이상할 수 있음

<br>

💡 해결 방법 3

- 부모 요소의 `overflow` 속성에 `visible(초기값)` 이 아닌 다른 속성을 부여한다

어떻게 가능❓

- `overflow` 속성은 기본적으로 `visible` 값으로 설정되어있다
  - 자식 요소가 부모 요소에 비해 넘쳐보여도 그냥 다 보이게 하겠다
  - 즉 모든 요소가 하나의 페이지 위에 있는 것
- `overflow` 속성에 `visible` 이 아닌 다른 값을 지정하면?
  - 전체 페이지 안에 새끼 페이지(독립적인 영역/Block Formatting Context)가 하나 더 생겼다고 상상하면 됨
  - 부모 자식 간 마진 병합 현상이 해결됨
  - 보통 `overflow: hidden;` 값을 통해 해결함

🚫 `box-shadow` 속성을 사용할 경우 그림자가 잘리는 문제가 발생

<br>

💡 해결 방법 4

- 부모 요소에 `padding` 이나 `border` 를 1px만 넣어줘도 해결 가능

🚫 우리가 원하지 않는 디자인적 변화가 눈에 보임

<br>

💡 해결 방법 5

- 부모 요소와 자식 요소가 맞닿는 곳에 빈 테이블을 가상 요소(pseudo-elements)로 삽입해 해결한다
- `clearfix` 등의 별개의 클래스로 만들어 공공재처럼 활용 가능
- 마진 병합 현상이 일어나는 부모 요소에 클래스로 적용시킨다

```html
<div class="parents clearfix">
  <div class="child"></div>
</div>
```

```css
/* Commons */
.clearfix::before,
.clearfix::after {
  content: ' ';
  display: table;
}
```

<br>

📝 오늘의 회고

---

1만시간 과제 CSS 작업을 하는데 줄간격이 자꾸 이상하게 나오길래 뭘 잘못 건드렸나 했는데 em단위 상속때문에 문제가 생긴다는 걸 처음 알았다..  
1em이라는 단위 자체가 상속되는줄 알았는데 부모 요소 폰트 사이즈 기준으로 계산된 값이 그대로 상속된다는 걸 알고 코드를 뜯어고쳤다😥  
애매하게 알고 넘어가면 언제나 피를 보는 법이다^^..

오늘 배운 내용 중에 서체 부분이 제일 흥미로웠다. line-height가 정확히 어떤 영역을 가리키는지, font-size와의 차이는 무엇인지 이런 걸 파고드는 게 재밌다🤭 CSS 이론은 너무 재밌는데 막상 내손으로 코드를 짜기 시작하면 누덕누덕 기우는 느낌이 드는 게 너무 슬프지만..  
견고한 코드를 위해 항상 종찬 강사님이 하신 말씀을 마음에 새겨야겠다😂 언제나 레이아웃이 먼저다..
